name: Validate PR Agent Session Metadata

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, labeled]

permissions:
  contents: read
  pull-requests: read

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Ensure PR has parsable journal metadata or is exempted
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const labels = (pr.labels || []).map(l => l.name);
            const body = pr.body || '';

            const REQUIRED_KEYS = ['host','pid','agent','model','owner'];

            function ok(msg) {
              core.info(msg);
            }

            function fail(msg) {
              core.setFailed(msg + '\n\nFormats acceptés:\n' +
                '- Label unique: "journal:host=totoro,pid=163849,agent=GitHubCopilot,model=GPT-5,owner=agent"\n' +
                '- OU: Label "journal" + bloc JSON dans le corps du PR:\n' +
                '<!-- journal: {"host":"totoro","pid":163849,"agent":"GitHubCopilot","model":"GPT-5","owner":"agent"} -->\n' +
                '\nAstuce: ajoutez le label "copilotage-exempt" pour bypass ponctuel.');
            }

            function hasAllKeys(obj) {
              return REQUIRED_KEYS.every(k => Object.prototype.hasOwnProperty.call(obj, k) && String(obj[k]).length > 0);
            }

            function parseKVP(labelName) {
              // Expect: journal:host=totoro,pid=163849,agent=GitHubCopilot,model=GPT-5,owner=agent
              const m = labelName.match(/^journal:(.*)$/);
              if (!m) return null;
              const kvp = m[1];
              const obj = {};
              kvp.split(/[,\s]+/).forEach(pair => {
                if (!pair) return;
                const idx = pair.indexOf('=');
                if (idx === -1) return;
                const k = pair.slice(0, idx).trim();
                const v = pair.slice(idx + 1).trim();
                if (k) obj[k] = v;
              });
              // Normalize pid as number if possible
              if (obj.pid && /^\d+$/.test(String(obj.pid))) obj.pid = Number(obj.pid);
              return obj;
            }

            const exempt = labels.includes('copilotage-exempt');
            if (exempt) {
              ok('Bypass enabled via label copilotage-exempt.');
              return;
            }

            // 1) Try a single parsable label starting with "journal:"
            const journalLike = labels.find(n => n.toLowerCase().startsWith('journal:'));
            if (journalLike) {
              const parsed = parseKVP(journalLike);
              if (parsed && hasAllKeys(parsed)) {
                ok('Validation OK: métadonnées parsées depuis le label unique "' + journalLike + '".');
                return;
              }
            }

            // 2) Try label "journal" combined with JSON block in PR body
            if (labels.map(n => n.toLowerCase()).includes('journal')) {
              const match = body.match(/<!--\s*journal:\s*(\{[\s\S]*?\})\s*-->/i);
              if (match) {
                try {
                  const data = JSON.parse(match[1]);
                  if (hasAllKeys(data)) {
                    ok('Validation OK: métadonnées parsées depuis le bloc JSON en commentaire du PR.');
                    return;
                  }
                } catch (e) {
                  core.warning('JSON de journal invalide: ' + e.message);
                }
              }
            }

            fail('Métadonnées de session manquantes ou incomplètes.');