#!/usr/bin/env python3
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
DOCS_MODULES = ROOT / 'docs' / 'modules' / 'index.md'
DOCS_MODULES_EN = ROOT / 'docs' / 'en' / 'modules' / 'index.md'
AGG_ROOT = ROOT / 'docs' / 'modules' / '_ext'

OWNER = 'stephanedenis'
REPO = 'PaniniFS'
BASE_URL = f"https://github.com/{OWNER}/{REPO}"

def prettify(name: str) -> str:
    # "execution-orchestrator" -> "Execution Orchestrator"
    return name.replace('-', ' ').replace('_', ' ').title()

def discover():
    modules = []
    modules_dir = ROOT / 'modules'
    if not modules_dir.exists():
        return modules
    for p in sorted(modules_dir.iterdir()):
        if not p.is_dir():
            continue
        # Submodule or regular dir; keep it regardless of .git presence
        readme = p / 'README.md'
        docs_index = p / 'docs' / 'index.md'
        entry = {
            'name': p.name,
            'title': prettify(p.name),
            'has_readme': readme.exists(),
            'has_docs_index': docs_index.exists(),
        }
        modules.append(entry)
    return modules

def render(mods):
    lines = [
        '# Documentation des modules',
        '',
        '<!-- Generated by scripts/generate_modules_docs_index.py; do not edit manually. -->',
        '',
        "Chaque sous-module dispose idéalement d’un dossier `docs/` pour sa documentation spécifique (schémas, guides, API, ADRs).",
    "Quand possible, ces documents sont agrégés localement (docs/modules/_ext/<module>/). À défaut, on renvoie vers GitHub.",
        '',
        '## Modules détectés',
        '',
    ]
    for m in mods:
        name = m['name']
        title = m['title']
        local_index = AGG_ROOT / name / 'index.md'
        if local_index.exists():
            url = f"../modules/_ext/{name}/index.md"
            desc = f"— Docs agrégées du module {name} (local)"
        elif m['has_docs_index']:
            url = f"{BASE_URL}/blob/HEAD/modules/{name}/docs/index.md"
            desc = f"— Docs du module {name} (index)"
        elif m['has_readme']:
            url = f"{BASE_URL}/blob/HEAD/modules/{name}/README.md"
            desc = f"— README du module {name}"
        else:
            url = f"{BASE_URL}/tree/HEAD/modules/{name}"
            desc = f"— Sources du module {name}"
        lines.append(f"- [{title}]({url}) {desc}.")
    lines.append('')
    return '\n'.join(lines)

def render_en(mods):
    lines = [
        '# Module documentation',
        '',
        '<!-- Generated by scripts/generate_modules_docs_index.py; do not edit manually. -->',
        '',
        "Each submodule should ideally provide a `docs/` folder for its own documentation (diagrams, guides, APIs, ADRs).",
    "When possible, these docs are aggregated locally (docs/modules/_ext/<module>/). Otherwise, links point to GitHub.",
        '',
        '## Detected modules',
        '',
    ]
    for m in mods:
        name = m['name']
        title = m['title']
        local_index = AGG_ROOT / name / 'index.md'
        if local_index.exists():
            url = f"../../modules/_ext/{name}/index.md"
            desc = f"— Aggregated docs for module {name} (local)"
        elif m['has_docs_index']:
            url = f"{BASE_URL}/blob/HEAD/modules/{name}/docs/index.md"
            desc = f"— Module {name} docs (index)"
        elif m['has_readme']:
            url = f"{BASE_URL}/blob/HEAD/modules/{name}/README.md"
            desc = f"— Module {name} README"
        else:
            url = f"{BASE_URL}/tree/HEAD/modules/{name}"
            desc = f"— Module {name} sources"
        lines.append(f"- [{title}]({url}) {desc}.")
    lines.append('')
    return '\n'.join(lines)

def main():
    mods = discover()
    DOCS_MODULES.parent.mkdir(parents=True, exist_ok=True)
    # French
    DOCS_MODULES.write_text(render(mods), encoding='utf-8')
    # English
    DOCS_MODULES_EN.parent.mkdir(parents=True, exist_ok=True)
    DOCS_MODULES_EN.write_text(render_en(mods), encoding='utf-8')

if __name__ == '__main__':
    main()
